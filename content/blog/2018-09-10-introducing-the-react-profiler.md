---
title: "Представляем React Profiler"
author: [bvaughn]
---
React 16.5 добавляет поддержку нового плагина профилировщика DevTools.
Этот плагин использует [экспериментальный API профилировщика](https://github.com/reactjs/rfcs/pull/51) React для сбора информации о времени выполнения для каждого отображаемого компонента с целью выявления узких мест производительности в приложениях React.
Он будет полностью совместим с нашими грядущими функциями [time slicing и suspense](/blog/2018/03/01/sneak-peek-beyond-react-16.html).

В этом посте рассматриваются следующие темы:
* [Профилирование приложения](#profiling-an-application)
* [Чтение данных о производительности](#reading-performance-data)
  * [Просмотр коммитов](#browsing-commits)
  * [Фильтрация коммитов](#filtering-commits)
  * [Flame chart диаграмма](#flame-chart)
  * [Ранжированная диаграмма](#ranked-chart)
  * [Диаграмма компонента](#component-chart)
  * [Взаимодействия](#interactions)
* [Исправление проблем](#troubleshooting)
  * [Данные профилирования не записаны для выбранного root](#no-profiling-data-has-been-recorded-for-the-selected-root)
  * [Нет данных о времени выполнения для выбранного коммита](#no-timing-data-to-display-for-the-selected-commit)
* [Подробное видео](#deep-dive-video)

## Профилирование приложения {#profiling-an-application}

DevTools покажет вкладку «Profiler» для приложений, поддерживающих новый API профилирования:

![New DevTools "profiler" tab](../images/blog/introducing-the-react-profiler/devtools-profiler-tab.png)

> Примечание:
>
> `react-dom` 16.5+ поддерживает профилирование в DEV режиме.
> Для профилирования в production доступен пакет `react-dom/profiling`.
> Подробнее о том, как использовать этот пакет [fb.me/react-profiling](https://fb.me/react-profiling) 

Панель «Profiler» изначально будет пустой. Нажмите кнопку записи, чтобы начать профилирование:

![Click "record" to start profiling](../images/blog/introducing-the-react-profiler/start-profiling.png)

После того как вы начали запись, DevTools будет автоматически собирать информацию о производительности при каждом рендеринге вашего приложения.
Используйте свое приложение как обычно.
Когда вы закончили профилирование, нажмите кнопку «Stop».

![Click "stop" when you are finished profiling](../images/blog/introducing-the-react-profiler/stop-profiling.png)

Предполагая, что ваше приложение рендерилось хотя бы один раз во время профилирования, DevTools покажет несколько способов просмотра данных о производительности.
Мы [рассмотрим каждый из них ниже](#reading-performance-data).

## Чтение данных о производительности {#reading-performance-data}

### Просмотр коммитов {#browsing-commits}
Концептуально React выполняет работу в два этапа:

* Этап **рендеринга** определяет какие изменения необходимо внести, например в DOM. На этом этапе React вызывает `render`, а затем сравнивает результат с предыдущим рендером.
* Этап **коммита (фиксации)** -- это когда React применяет любые изменения. (В случае React DOM -- это когда React вставляет, обновляет и удаляет узлы DOM.) На этом этапе React также вызывает методы жизненного цикла такие, как`componentDidMount` и `componentDidUpdate`.

Профилировщик DevTools группирует информацию о производительности по коммитам.
Коммиты отображаются на гистограмме в верхней части профилировщика:

![Bar chart of profiled commits](../images/blog/introducing-the-react-profiler/commit-selector.png)

Каждый столбец на диаграмме представляет собой отдельный коммит, черным цветом помечен текущий выбранный коммит.
Вы можете кликать по столбцам (или по кнопкам со стрелками влево/вправо), чтобы выбрать другой коммит.

Цвет и высота каждого столбца соответствуют тому, сколько времени потребовалось для рендеринга этого коммита.
(Более высокие желтые столбцы занимали больше времени, чем короткие синие.)

### Фильтрация коммитов {#filtering-commits}

Чем дольше вы профилируете, тем больше раз будет рендериться ваше приложение.
В некоторых случаях вы можете получить _слишком много коммитов_, чтобы их было легко обработать.
Профилировщик предлагает механизм фильтрации, чтобы помочь в этом.
Используйте его, чтобы указать порог, и профилировщик скроет все коммиты, которые были _быстрее_ этого значения.

![Filtering commits by time](../images/blog/introducing-the-react-profiler/filtering-commits.gif)

### Flame chart диаграмма {#flame-chart}

Flame chart диаграмма представляет состояние вашего приложения для конкретного коммита.
Каждый столбец в диаграмме представляет React-компонент (например `App`, `Nav`).
Размер и цвет столбца показывают сколько времени потребовалось для рендера компонента и его дочерних компонентов.
(Ширина столбца показывает сколько времени было потрачено _при последнем рендере_. Цвет показывает сколько времени было потрачено _как часть текущего коммита_.)

![Example flame chart](../images/blog/introducing-the-react-profiler/flame-chart.png)

> Примечание:
>
> Ширина столбца указывает сколько времени потребовалось для рендера компонента (и его дочерних компонентов) при последнем рендере.
> Если компонент не подвергался ререндеру как часть этого коммита, время представляет предыдущий рендер.
> Чем больше компонент, тем больше времени требуется на рендер.
> 
> Цвет столбца указывает сколько времени потребовалось компоненту (и его дочерним компонентам) для рендера в выбранном коммите.
> Желтые компоненты занимали больше времени, синие компоненты - меньше времени, а серые компоненты вообще не рендерелись во время текущего коммита.

Например, показанный выше коммит занял в общей сложности 18.4мс для рендера.
Компонент `Router` оказался «самым дорогим» для рендера (занял 18.4мс).
Большая часть этого времени была связана с двумя его дочерними компонентами, `Nav` (8.4мс) и `Route` (7.9мс).
Остальное время было разделено между оставшимися дочерними компонентами или потрачено на собственный метод рендера компонента.

Вы можете кликать на компоненты, чтобы увеличивать или уменьшать масштаб диаграммы:
![Click on a component to zoom in or out](../images/blog/introducing-the-react-profiler/zoom-in-and-out.gif)

Клик по компоненту также выберет его и отобразит информацию на правой боковой панели, которая включает его `props` и `state` на момент этого коммита.
Вы можете углубиться в них, чтобы узнать больше о том, что компонент фактически рендерил во время коммита:

![Viewing a component's props and state for a commit](../images/blog/introducing-the-react-profiler/props-and-state.gif)

В некоторых случаях выбор компонента и переход между коммитами также может дать подсказку о том, _почему_ компонент рендерился:

![Seeing which values changed between commits](../images/blog/introducing-the-react-profiler/see-which-props-changed.gif)

На изображении выше показано, что `state.scrollOffset` изменился между коммитами.
Вероятно, это вызвало повторный рендер компонента `List`.

### Ранжированная диаграмма {#ranked-chart}

Ранжированная диаграмма представляет собой отдельный коммит.
Каждая полоса на диаграмме представляет компонент React (например `App`, `Nav`).
Диаграмма упорядочена таким образом, что компоненты, рендер которых занимает больше всего времени, находятся наверху.

![Example ranked chart](../images/blog/introducing-the-react-profiler/ranked-chart.png)

> Примечание:
>
> Время рендера компонента включает время, затраченное на рендер его дочерних компонентов
> поэтому компоненты, рендер которых занял больше всего времени, обычно находятся в верхней части дерева.

Как и в случае с flame chart диаграммой, вы можете увеличивать или уменьшать масштаб ранжированной диаграммы, нажимая на компоненты.

### Диаграмма компонента {#component-chart}

Иногда полезно узнать, сколько раз конкретный компонент рендерился во время профилирования.
Диаграмма компонента предоставляет эту информацию в виде столбчатой диаграммы.
Каждый столбец на диаграмме представляет время рендера компонента.
Цвет и высота каждого столбца соответствуют тому, сколько времени потребовалось для рендера компонента _по сравнению с другими компонентами_ в конкретном коммите.

![Example component chart](../images/blog/introducing-the-react-profiler/component-chart.png)

На диаграмме выше показано, что компонент `List` был отрендерен 11 раз.
Он также показывает, что каждый раз при рендере это был самый «дорогой» компонент в коммите (это означает, что он занимал больше всего времени).

Чтобы просмотреть эту диаграмму, дважды кликните на компонент, _либо_ выберите компонент и кликните на значок синей гистограммы на правой панели сведений.
Вы можете вернуться к предыдущей диаграмме, нажав кнопку «x» на правой панели деталей.
Вы также можете дважды кликнуть по определенному столбцу, чтобы просмотреть дополнительную информацию об этой коммите.

![How to view all renders for a specific component](../images/blog/introducing-the-react-profiler/see-all-commits-for-a-fiber.gif)

Если выбранный компонент вообще не рендерился во время сеанса профилирования, будет показано следующее сообщение:

![No render times for the selected component](../images/blog/introducing-the-react-profiler/no-render-times-for-selected-component.png)

### Взаимодействия {#interactions}

React недавно добавил еще один [экспериментальный API](https://fb.me/react-interaction-tracing) для отслеживания _причины_ обновления.
«Взаимодействия» отслеживаемые этим API, также будут отображаться в профилировщике:

![The interactions panel](../images/blog/introducing-the-react-profiler/interactions.png)

На изображении выше показан сеанс профилирования, в котором было отслежено четыре взаимодействия.
Каждая строка представляет отслеживаемое взаимодействие.
Цветные точки в строке обозначают коммиты, связанные с этим взаимодействием.

Вы также можете увидеть какие взаимодействия были отслежены для конкретного коммита на flame chart диаграмме и в отображении ранжированной диаграммы:

![List of interactions for a commit](../images/blog/introducing-the-react-profiler/interactions-for-commit.png)

Вы можете перемещаться между взаимодействиями и коммитами, нажимая на них:

![Navigate between interactions and commits](../images/blog/introducing-the-react-profiler/navigate-between-interactions-and-commits.gif)

API трассировки все еще новый и мы расскажем о нем более подробно в одном из следующих постах.

## Исправление проблем {#troubleshooting}

### Данные профилирования не записаны для выбранного root {#no-profiling-data-has-been-recorded-for-the-selected-root}

Если ваше приложение имеет несколько «roots», после профилирования вы можете увидеть следующее сообщение:
![No profiling data has been recorded for the selected root](../images/blog/introducing-the-react-profiler/no-profiler-data-multi-root.png)

Это сообщение означает, что не было записано никаких данных о производительности для root выбранного в панели «Элементы».
В этом случае попробуйте выбрать другой root на этой панели, чтобы просмотреть информацию профилирования для этого root:

![Select a root in the "Elements" panel to view its performance data](../images/blog/introducing-the-react-profiler/select-a-root-to-view-profiling-data.gif)

### Нет данных о времени выполнения для выбранного коммита {#no-timing-data-to-display-for-the-selected-commit}

Иногда коммит может быть настолько быстрым, что `performance.now()` не дает DevTools какой-либо значимой информации о времени выполнения.
В этом случае будет показано следующее сообщение:

![No timing data to display for the selected commit](../images/blog/introducing-the-react-profiler/no-timing-data-for-commit.png)

## Подробное видео {#deep-dive-video}

В следующем видео показано, как профилировщик React можно использовать для обнаружения и улучшения узких мест в реальном приложении React.

<br>

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/nySib7ipZdk?rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
